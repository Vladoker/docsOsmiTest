---
title: Sequential Agents
description: Полное введение в архитектуру Sequential Agents в Платформа ключевые компоненты и принципы проектирования флоу.
---



::note
**Дисклеймер**.  Документация предназначена для пользователей Платформа и описывает создание разговорных флоу на базе архитектуры Sequential Agents. Это не исчерпывающая справка по LangGraph и не определяет отраслевые стандарты или базовые концепции LangGraph.
::

## Концепция

Sequential Agents в Платформа построены поверх LangGraph и представляют рабочий процесс как ориентированный циклический граф (DCG), что позволяет задавать контролируемые циклы и итерации. Граф из взаимосвязанных Узлов определяет последовательный поток данных и действий, позволяя агентам обрабатывать вход, выполнять задачи и генерировать ответы структурированно.

<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-34db743f8470c3d04403aa53dfcb564ad467cb5d%2Fseq-21.svg?alt=media" alt=""><figcaption></figcaption></figure>

### Понимание DCG-архитектуры Sequential Agents

Архитектура упрощает управление сложными разговорными флоу за счёт чёткой последовательности операций в структуре DCG.



**Основные принципы и терминология**  

* Обработка на базе Узлов. Каждый Узел — дискретный блок с собственной ролью: обработка языка, вызов инструментов, условная логика и т. п.
* Поток данных как соединения. Рёбра графа — это передача данных: выход одного Узла становится входом следующего.
* Управление состоянием. State (состояние) — общий объект, доступный всем Узлам на протяжении разговора.


## Sequential Agents vs Multi-Agents

Обе системы в Платформа используют LangGraph и общие принципы, но Sequential Agents дают более низкоуровневый контроль над каждым шагом.
* Multi-Agents — иерархия с центральным Supervisor, который декомпозирует задачи и делегирует их Workers. Многие базовые элементы (например, условные ветвления) преднастроены «под капотом», что упрощает сборку команд агентов.


* Sequential Agents — «конвейер», в котором данные идут по цепочке Узлов; подходят для задач, требующих строгого порядка операций и пошагового доработки данных. Они дают полный контроль над логикой: параллельное выполнение, условия, Loop, работа со State, динамическое ветвление.


### Новые узлы: State, Loop и Condition

* Узел State. Определяет настраиваемое состояние с начала флоу. Это общий JSON-объект, который читается/обновляется другими Узлами.
* Узел Loop. Реализует контролируемые циклы: повтор последовательностей Узлов по условию (итеративная доработка, уточнения и т. д.).
* Узлы Condition.
  * Condition — детерминированные правила (сравнения, проверки).
  * Condition Agent — маршрутизация с «пониманием» через БЯМ (агентная логика + условия).


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-1e00abb8545ee624e4218bd550cf53a6214bffda%2Fseq-20.png?alt=media" alt=""><figcaption></figcaption></figure>



### Как выбрать систему

* **Проще — Multi-Agents.** Линейные процессы без параллельных веток и без HITL — быстрый запуск.
* **Гибче — Sequential Agents.** Нужны параллельные действия, динамика диалога, пользовательский State, поддержка HITL — выбирайте Sequential.


| Критерий        | Multi-Agent                                | Sequential Agent                                                               |
| --------------- | ------------------------------------------ | ------------------------------------------------------------------------------ |
| Структура       | Иерархия: Supervisor → Workers             | Линейная/циклическая/ветвящаяся; узлы соединяются последовательно, с условиями |
| Workflow        | Гибкий: декомпозиция на подзадачи по одной | Очень гибкий: параллель, сложные диалоги, ветвления, циклы в один ход          |
| Параллельность  | Нет (одна задача за раз)                   | Да (несколько действий в одном запуске)                                        |
| State           | Имплицитный                                | Эксплицитный: задаётся в Узле State, обновляется в Узлах                       |
| Инструменты     | Доступны воркерам                          | Через Узел Agent и Узел Tool                                                   |
| HITL            | Нет                                        | Есть: «Require Approval» в Узлах Agent/Tool                                    |
| Сложность       | Более высокий уровень абстракции           | Более низкий уровень; требуется продуманная логика и State                     |
| Когда применять | Линейные процессы, поочерёдные подзадачи   | Динамичные флоу, параллель, ветвления, множественные решения по ходу           |


::note
**Примечание**. Multi-Agents — надстройка над Sequential, но опыт проектирования различается; сравнение дано как разных подходов.
::

## Узлы Sequential Agents

Ниже — обзор 10 специализированных Узлов: назначение, входы/выходы, настройки и практики.

<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-52c437a8af17a48357576a2049ceb8348a4b3fab%2Fseq-00.png?alt=media" alt=""><figcaption></figcaption></figure>

***

## 1.Узел Start

Точка входа любого флоу: принимает первый запрос пользователя, инициализирует State и запускает процесс.

<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-7d99d3172d1706b294ab496d24c1eb9ebd6adf16%2Fseq-02.png?alt=media" alt="" width="300"><figcaption></figcaption></figure>

Что делает:  

* Назначает дефолтную БЯМ (Chat Model) с поддержкой function calling.
* Подключает Agent Memory (опционально) для истории.
* Подключает Узел State для кастомного состояния.
* Может подключить Moderation входных данных



### Входы (обязательность)

* Chat Model — Да (БЯМ с function calling).
* Agent Memory Node — Нет.
* State Node — Нет.
* Input Moderation — Нет.            
 
 
 
 

### Выходы: к Узлу Agent, LLM, Condition Agent, Condition.

The Start Node can connect to the following nodes as outputs:

Выбор БЯМ. Убедитесь, что поддерживает function calling; при необходимости переопределяйте модель в Узлах ниже.

### Best Practices

Контекст. Для персонализации/долгих диалогов используйте память.


## 2. Узел Agent Memory

Механизм персистентной памяти: хранит `state.messages` и кастомный **State** между взаимодействиями.  

Хранилище по умолчанию: SQLite (таблица checkpoints).  

Структура checkpoints (важное):  
* `thread_id` — сессия (разговор).
* `checkpoint_id` — шаг исполнения (Узел).
* `parent_id` — родительский шаг.
* `checkpoint` — JSON-снимок State (включая историю и значения переменных).
* `metadata` — служебные данные узла.

Зачем: трекинг исполнения, восстановление с чекпоинта, долговременный контекст.


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-bcd9409b16b44c6289d7b881d9b321b4f2f303c3%2Fseq-03.png?alt=media" alt="" width="299"><figcaption></figcaption></figure>

Настройки:

* Database — Да (сейчас поддержан SQLite).
* Database File Path — Нет (опционально).

## Best Practices
Используйте только там, где нужна долговременная память; для простых сценариев избыточна.


## 3. Узел State

Добавляет кастомное State (JSON) в флоу с самого начала (подключается к Start). По умолчанию существует неизменяемый `state.messages` — история диалога. Узел State расширяет объект состояния вашими ключами.


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-97868ec4ed90af5e56cca06f1ef85ce9715c8fa0%2Fseq-04.png?alt=media" alt="" width="299"><figcaption></figcaption></figure>

**Выходы: только к Узлу Start.**

### Параметры (обязательность)

* Custom State — Да (JSON начального состояния).


### Операции над ключами:

* Replace — замена; при null сохраняет прежнее.
* Append — добавление; итог — массив.

#### Example using JS



```js
{
    aggregate: {
        value: (x, y) => x.concat(y), // добавляем новое сообщение к имеющимся
        default: () => []
    }
}
```


#### Пример (таблица):

| Key      | Operation | Default Value |
| -------- | --------- | ------------- |
| userName | Replace   | null          |

<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-fb09eba7990e232a74a670bc5a6f568b37414ac5%2Fseq-14.png?alt=media" alt="" width="375"><figcaption></figcaption></figure>


#### Пример (API):

```json
{
  "question": "hello",
  "overrideConfig": {
    "stateMemory": [
      { "Key": "userName", "Operation": "Replace", "Default Value": "somevalue" }
    ]
  }
}
```

### Best Practices

* Проектируйте структуру State заранее; используйте говорящие ключи; храните только то, что реально нужно; для персистентности — подключайте Agent Memory.



## 4. Узел Agent

Центральный «оркестратор/решатель». Получает вход (включая state.messages и кастомный State), действует по Промту (persona), при необходимости вызывает инструменты, может требовать HITL, затем формирует ответ.
Входы (один из): Start / Agent / Condition / Condition Agent / LLM / Tool.
Выходы: Agent / LLM / Condition Agent / Condition / End / Loop.



:img{ src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-7de9c9adca14235393e86bef3d8b069fb7a08f93%2Fsa-agent.png?alt=media"  alt="01"}




Настройка (ключевое):  
* Agent Name — Да.
* System Prompt — Нет (роль/персона).
* Require Approval (HITL) — Нет (по умолчанию False).
* Human Prompt / Approval Prompt / Approve/Reject Button Text — опционально.
* Update State — опционально (обновление кастомного State).
* Max Iteration — опционально (ограничение итераций).

## Best Practices
* Ясный System Prompt; тщательно отбирайте инструменты; включайте HITL для чувствительных операций; разумно обновляйте State.


## 5. Узел LLM

Работает с той же БЯМ, что и Agent, но фокус на языковой обработке и, главное, на структурированном выводе JSON.


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-194e1bf3e57eaa8819e785ac355e9ae176272548%2Fsa-llm.png?alt=media" alt="" width="341"><figcaption></figcaption></figure>

Преимущества:  

* JSON Structured Output — явная схема (ключи/типы/enum/описания) для предсказуемого извлечения данных.
* HITL смещён на уровень Узла Tool (более гибко).


Входы (один из): Start / Agent / Condition / Condition Agent / LLM / Tool.
Выходы: Agent / LLM / Tool / Condition Agent / Condition / End / Loop.

Настройки:  

* LLM Node Name — Да. 
* System Prompt / Human Prompt — опционально.
* JSON Structured Output — опционально.
* Update State — опционально.


## Best Practices
Давайте чёткий System Prompt; включайте JSON Structured Output только когда нужно; планируйте использование инструментов через Tool; включайте HITL точечно; обновляйте State по делу.


## 6. Узел Tool

Интеграция и запуск внешних инструментов/АПИ. Получает вход от LLM; при наличии `tool_calls` выполняет указанный инструмент (может требовать HITL), возвращает результат далее (или назад в LLM, если нет явного выхода).


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-fffa2e7c3a0ac39b1a8a0aa6cfad6574bbffa91d%2Fseq-07.png?alt=media" alt="" width="300"><figcaption></figcaption></figure>

Входы:  
* LLM Node — Да.
* External Tools — Нет (список доступных инструментов).


**Выходы: Agent / LLM / Condition Agent / Condition / End / Loop.**

Настройки:

* Tool Node Name — Да.
* Require Approval (HITL) — Нет.
* Approval Prompt / Approve / Reject Button Text — опционально.
* Update State — опционально.


## Best Practices
Включайте HITL для чувствительных действий; делайте информативные Approval Prompt.


## 7. Узел Condition

Детерминированная развилка по заданным правилам. Анализирует историю и кастомный State, затем отправляет поток на нужный выход.


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-12f037bd10f850204069bd5e2dda01465f35deaf%2Fseq-08.png?alt=media" alt="" width="299"><figcaption></figcaption></figure>

Как работает:
* Получает вход (Start / Agent / LLM / Tool).
* Имеет доступ к истории и State.
* Проверяет условия (таблица или JS).
* Идёт по первому сработавшему выходу, иначе — End.


Оценка условий:
* Таблица: сверху вниз; первый true активирует соответствующий выход; иначе — End.
* Код (JS): явно возвращайте имя выбранного выхода (включая дефолтный «End»).
* Единственный активный выход за раз.


Подключение выходов: к Agent / LLM / End / Loop.

Настройки:
* Condition Node Name — опционально.
* Condition — Да (таблица или JS).


## Best Practices
Узел Condition Agent


## 8. Узел Condition Agent

Интеллектуальная маршрутизация: сочетает возможности LLM (в т. ч. JSON Structured Output) и условной логики в одном Узле. Учитывает весь контекст диалога и кастомный State.
Ключевые возможности:
Единый Узел для «понимания» и выбора ветки.


Условия — таблица или JS.


Опционально структурирует свой вывод (JSON) — удобно для стабильных проверок.

Входы (один из): Start / Agent / LLM / Tool.
Выходы: как у Condition (динамический выбор одного пути).
Настройки:
Name — опционально.


Condition — Да (таблица/JS).


System Prompt / Human Prompt — опционально.
JSON Structured Output — опционально.


Best Practices
Чёткий System Prompt; используйте JSON Structured Output для надёжности условий
Чем отличается от Condition: добавляет агентное «понимание» и (при необходимости) структурированный вывод.


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-080d051907f61aa1e106e7eae81b168d0f249c40%2Fseq-09.png?alt=media" alt="" width="299"><figcaption></figcaption></figure>



## 9. Узел Loop

TСоздаёт цикл, возвращая исполнение к заданному целевому Узлу (Agent или LLM). Передаёт текущее State и результаты предыдущего шага назад в цель.
Пример: многократное уточнение параметров поиска (пока пользователь доволен).
Входы (один из): Agent / LLM / Tool / Condition / Condition Agent.
 Настройка:
Loop To — Да (целевой Узел Agent или LLM).
 Выходы: нет (ретаргетинг исполнения).


Best Practices
Фиксируйте цель цикла и критерии выхода; избегайте бесконечных петель.


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-57f8e16419e7630b996105bc1de9d34f5ee574ea%2Fsa-loop.png?alt=media" alt="" width="335"><figcaption></figcaption></figure>



## 10. Узел End


Финальная точка — никакой дальнейшей обработки.
Входы (один из): Agent / LLM / Tool / Condition / Condition Agent.
 Выходы: нет.
Best Practices
При необходимости перед завершением сформируйте финальный ответ пользователю (подключите LLM/Agent перед End).


<figure><img src="https://823733684-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F00tYLwhz5RyR7fJEhrWy%2Fuploads%2Fgit-blob-76b1d08e2ce29e11a3e3a45877392212c584d348%2Fseq-end-node.png?alt=media" alt="" width="375"><figcaption></figcaption></figure>

## Condition vs Condition Agent

Оба Узла создают динамику, но подходы различаются.


| Характеристика          | Condition                | Condition Agent                                |
| ----------------------- | ------------------------ | ---------------------------------------------- |
| Логика решения          | Предопределённые правила | Агентное «понимание» + условия                 |
| Участие БЯМ             | Нет                      | Да (анализ контекста)                          |
| Структурированный вывод | Нет                      | Есть (рекомендуется)                           |
| Где проверяем           | По полной истории/State  | По выходу самого агента (структурному или нет) |
| Сложность               | Простые ветвления        | Нюансная, контекстная маршрутизация            |
| Кейсы                   | Возраст, ключевое слово  | Интент, сентимент, сложный контекст            |

Выбор:
* Condition — для чётких простых правил.
* Condition Agent — когда нужна «понимающая» маршрутизация и/или структурированный выход.


## Agent vs LLM

Оба узла «агентны» (используют БЯМ), но роли различны.

| Характеристика          | Agent                                                             | LLM                                                                 |
| ----------------------- | ----------------------------------------------------------------- | ------------------------------------------------------------------- |
| Инструменты             | Сам вызывает/менеджит несколько инструментов; HITL на уровне Узла | Инструменты через Узел Tool; HITL на уровне каждого Tool            |
| HITL                    | Глобально на Узле Agent (все инструменты)                         | Тонкая настройка на отдельных Tool                                  |
| Структурированный вывод | Натуральный вывод ЛМ                                              | Есть явная JSON-схема для структуры                                 |
| Кейсы                   | Сложная оркестрация инструментов, простой HITL                    | Извлечение структурных данных, смешанный HITL, точечные Tool-вызовы |

Выбор:
* Agent — когда нужна многошаговая оркестрация инструментов с единым режимом HITL.
* LLM — когда важно извлекать структурированные данные (JSON) и независимо управлять HITL на уровне отдельных инструментов через Tool.