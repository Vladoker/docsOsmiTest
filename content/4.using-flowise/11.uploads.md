---
title: Uploads
description: Загрузка изображений, аудио и других файлов
---


Платформа позволяет загружать изображения, аудио и другие файлы прямо из чата. Ниже — как включить и использовать эти возможности.


## Image

Некоторые чат-модели поддерживают ввод изображений. Всегда проверяйте официальную документацию БЯМ, чтобы убедиться, что модель поддерживает image-input.
Поддерживаемые провайдеры/классы:


* [ChatOpenAI]()
* [AzureChatOpenAI]()
* [ChatAnthropic]()
* [AWSChatBedrock]()
* [ChatGoogleGenerativeAI]()
* [ChatOllama]()
* [Google Vertex AI]()

Обработка изображений работает только с некоторыми цепочками/агентами в Чат-флоу:

LLMChain, Conversation Chain, ReAct Agent, Conversational Agent, Tool Agent

Если включить опцию «Allow Image Upload» («Разрешить загрузку изображений»), вы сможете загружать изображения из интерфейса чата.

::static-image
---
image: /assets/Screenshot 2024-02-29 011714.png
---
::





Загрузка изображений через API


```python
import requests
API_URL = "http://localhost:3000/api/v1/prediction/<chatflowid>"

def query(payload):
    response = requests.post(API_URL, json=payload)
    return response.json()
    
output = query({
    "question": "Can you describe the image?",
    "uploads": [
        {
            "data": "data:image/png;base64,iVBORw0KGgdM2uN0", # base64 string or url
            "type": "file", # file | url
            "name": "Flowise.png",
            "mime": "image/png"
        }
    ]
})
```

```javascript
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/prediction/<chatflowid>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        }
    );
    const result = await response.json();
    return result;
}

query({
    "question": "Can you describe the image?",
    "uploads": [
        {
            "data": "data:image/png;base64,iVBORw0KGgdM2uN0", //base64 string or url
            "type": "file", // file | url
            "name": "Flowise.png",
            "mime": "image/png"
        }
    ]
}).then((response) => {
    console.log(response);
});
```


## Audio

В Chatflow Configuration можно выбрать модуль speech-to-text. Поддерживаются интеграции:


::static-image
---
image: /assets/Screenshot 2024-02-29 012538.png
---
::

Загрузка аудио через API


```python
import requests
API_URL = "http://localhost:3000/api/v1/prediction/<chatflowid>"

def query(payload):
    response = requests.post(API_URL, json=payload)
    return response.json()
    
output = query({
    "uploads": [
        {
            "data": "data:audio/webm;codecs=opus;base64,GkXf", # base64 string
            "type": "audio",
            "name": "audio.wav",
            "mime": "audio/webm"
        }
    ]
})
```

```javascript
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/prediction/<chatflowid>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        }
    );
    const result = await response.json();
    return result;
}

query({
    "uploads": [
        {
            "data": "data:audio/webm;codecs=opus;base64,GkXf", // base64 string
            "type": "audio",
            "name": "audio.wav",
            "mime": "audio/webm"
        }
    ]
}).then((response) => {
    console.log(response);
});
```


## Files

Загружать файлы можно двумя способами:

* RAG-загрузка (Retrieval-Augmented Generation)
* Полная загрузка (Full file upload)


Если включены обе опции, приоритет имеет полная загрузка.

### RAG File Uploads

Можно «на лету» upsert’ить загруженные файлы во Vector Store. Чтобы включить загрузки, выполните условия

В Чат-флоу должен быть Vector Store, поддерживающий файл-аплоад:


Pinecone, Milvus, Postgres, Qdrant, Upstash


Если в флоу несколько Vector Store, включить загрузку можно только для одного хранилища одновременно.



К входу документов выбранного Vector Store должен быть подключён хотя бы один Document Loader.

 Поддерживаемые лоадеры:


CSV File, Docx File, Json File, Json Lines File, PDF File, Text File, Unstructured File


<figure><img src="/assets/image (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

В чате можно загрузить один или несколько файлов.


::static-image
---
image: /assets/Screenshot 2024-08-26 170456.png
---
::

Как это работает:


Метаданные загруженных файлов дополняются chatId.  
Так файл связывается с текущей сессией.  
При запросах применяется OR-фильтр:  


метаданные содержат `Платформа_chatId` со значением текущего chatId, или  
метаданные не содержат `Платформа_chatId`.


(Пример векторного эмбеддинга, upsert’нутого в Pinecone.)


::static-image
---
image: /assets/image (4) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png
---
::

Через API — два шага

Шаг 1. Используйте Vector Upsert API с formData и chatId:


```python
import requests

API_URL = "http://localhost:3000/api/v1/vector/upsert/<chatflowid>"

# Use form data to upload files
form_data = {
    "files": ("state_of_the_union.txt", open("state_of_the_union.txt", "rb"))
}

body_data = {
    "chatId": "some-session-id"
}

def query(form_data):
    response = requests.post(API_URL, files=form_data, data=body_data)
    print(response)
    return response.json()

output = query(form_data)
print(output)
```

```javascript
// Use FormData to upload files
let formData = new FormData();
formData.append("files", input.files[0]);
formData.append("chatId", "some-session-id");

async function query(formData) {
    const response = await fetch(
        "http://localhost:3000/api/v1/vector/upsert/<chatflowid>",
        {
            method: "POST",
            body: formData
        }
    );
    const result = await response.json();
    return result;
}

query(formData).then((response) => {
    console.log(response);
});
```

 Шаг 2. Вызовите Prediction API, передав uploads и тот же chatId:


```python
import requests
API_URL = "http://localhost:3000/api/v1/prediction/<chatflowid>"

def query(payload):
    response = requests.post(API_URL, json=payload)
    return response.json()
    
output = query({
    "question": "What is the speech about?",
    "chatId": "same-session-id-from-step-1",
    "uploads": [
        {
            "data": "data:text/plain;base64,TWFkYWwcy4=",
            "type": "file:rag",
            "name": "state_of_the_union.txt",
            "mime": "text/plain"
        }
    ]
})
```

```javascript
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/prediction/<chatflowid>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        }
    );
    const result = await response.json();
    return result;
}

query({
    "question": "What is the speech about?",
    "chatId": "same-session-id-from-step-1",
    "uploads": [
        {
            "data": "data:text/plain;base64,TWFkYWwcy4=",
            "type": "file:rag",
            "name": "state_of_the_union.txt",
            "mime": "text/plain"
        }
    ]
}).then((response) => {
    console.log(response);
});
```


### Full File Uploads

При RAG-загрузке нельзя полноценно работать со структурированными данными (таблицы/спreadsheets) и делать «полное» суммирование — не хватает всего контекста. Иногда удобнее передать весь контент файла в промт БЯМ (особенно для моделей с большим контекстом вроде Gemini/Claude). Исследования сравнивают RAG и длинные контексты.
Чтобы включить полные загрузки, в Chatflow Configuration откройте вкладку File Upload и переключите тумблер.
В чате появится кнопка File Attachment — можно загрузить один или несколько файлов. Внутри File Loader преобразует каждый файл в текст.
Если ваш Чат-флоу использует Узел Chat Prompt Template, создайте вход через Format Prompt Values для передачи данных файла. Указанное имя входа (например, {file}) должно быть включено в поле Human Message.

Загрузка файлов через API


<figure><img src="/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2).png" alt=""><figcaption></figcaption></figure>


<figure><img src="/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Как видно из примеров, uploads требуют base64-строку. Чтобы получить base64 для файла, используйте Create Attachments API.


<figure><img src="/assets/chat-prompt-template-file-attachment.jpg" alt=""><figcaption></figcaption></figure>

To upload files with the API:


```python
import requests
API_URL = "http://localhost:3000/api/v1/prediction/<chatflowid>"

def query(payload):
    response = requests.post(API_URL, json=payload)
    return response.json()
    
output = query({
    "question": "What is the data about?",
    "chatId": "some-session-id",
    "uploads": [
        {
            "data": "data:text/plain;base64,TWFkYWwcy4=",
            "type": "file:full",
            "name": "state_of_the_union.txt",
            "mime": "text/plain"
        }
    ]
})
```

```js
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/prediction/<chatflowid>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        }
    );
    const result = await response.json();
    return result;
}

query({
    "question": "What is the data about?",
    "chatId": "some-session-id",
    "uploads": [
        {
            "data": "data:text/plain;base64,TWFkYWwcy4=",
            "type": "file:full",
            "name": "state_of_the_union.txt",
            "mime": "text/plain"
        }
    ]
}).then((response) => {
    console.log(response);
});
```


Разница между Full и RAG загрузками

Оба подхода решают разные задачи.
Full File Upload: весь файл парсится в строку и отправляется в БЯМ. Удобно для суммирования или извлечения ключевой информации. Но на очень больших файлах возможны неточности/«галлюцинации» из-за лимитов токенов.


RAG File Upload: рекомендуется для снижения токен-стоимости (не отправляется весь текст). Хорошо подходит для Q&A по документам, но не идеален для суммирования, т.к. нет полного контекста. Может работать дольше из-за процесса upsert.