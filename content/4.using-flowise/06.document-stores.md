---
title: Хранилища документов (Document Stores)
description:  Узнайте, как использовать хранилища документов Osmi AI, написанные @toi500
---

Document Stores в OSMI — это гибкий подход к управлению данными: вы можете загрузить, разделять и  подготовлять ваш набор данных, а также производить его вставку (upsert) в одном месте.

Такой централизованный подход упрощает работу с данными и позволяет эффективно управлять разными форматами, облегчая организацию и доступ к данным в приложении OSMI.


## Setup

В этом туториале мы настроим систему RAG (Retrieval Augmented Generation — извлечение с дополненной генерацией) для поиска информации о LibertyGuard Deluxe Homeowners Policy — теме, на которой БЯМ обучены недостаточно.
Используя Платформа Document Stores, мы подготовим и выполним upsert данных о LibertyGuard и его продуктах страхования жилья. Это позволит нашей RAG-системе точно отвечать на вопросы пользователей о страховых продуктах LibertyGuard


## 1. Добавьте Document Store

Начните с создания Document Store и присвойте ему имя. В нашем примере: “LibertyGuard Deluxe Homeowners Policy”.

<figure><img src="/assets/ds01.png" alt=""><figcaption></figcaption></figure>

## 2. Выберите Document Loader

Откройте созданный Document Store и выберите нужный Document Loader. В нашем случае датасет в формате PDF, поэтому используем PDF Loader.
Document Loaders — это специализированные Узлы, обрабатывающие ingestion различных форматов документов.


<figure><img src="/assets/ds02.png" alt=""><figcaption></figcaption></figure>

<figure><img src="/assets/ds03.png" alt=""><figcaption></figcaption></figure>

## 3. Подготовьте данные


### Шаг 1: Document Loader

Сначала загрузите PDF-файл.
Затем добавьте уникальный ключ метаданных. Это необязательно, но полезно: позволит при необходимости таргетировать и фильтровать этот датасет в будущем.

Каждый лоадер имеет преднастроенные метаданные; при необходимости можно использовать Omit Metadata Keys, чтобы удалить лишние ключи.

<figure><img src="/assets/ds04.png" alt=""><figcaption></figcaption></figure>

### Шаг 2: Text Splitter

Выберите Text Splitter для разбиения данных на чанки. В нашем случае — Recursive Character Text Splitter.
Text splitter разбивает загруженные документы на мелкие части (документы/чанки). Это критически важный препроцессинг по двум причинам:

* Скорость и релевантность извлечения. Хранение и запрос больших документов как единого объекта в векторной БД ведёт к медленным запросам и менее релевантным результатам. Разбиение на меньшие чанки даёт прицельное извлечение и ускоряет ответы, повышая точность.

* Снижение стоимости. Мы извлекаем только релевантные чанки, а не весь документ, поэтому БЯМ обрабатывает существенно меньше токенов. Это напрямую уменьшает стоимость (биллинг обычно по токенам) и снижает объём нерелевантной информации, отправляемой в БЯМ.

Стратегии разбиения текста:  

* Character Text Splitting. Деление на фиксированный размер в символах; просто, но может рвать слова/фразы и нарушать контекст.
* Token Text Splitting. Деление по границам слов/токенизации выбранной модели эмбеддингов; обычно даёт более семантически цельные чанки.
R* ecursive Character Text Splitting. Стремится сохранять семантическую цельность в пределах заданного размера; хорошо подходит для иерархических документов с секциями/подзаголовками: ищет логичные точки разрыва (концы предложений/секций), иногда слегка превышая целевой размер ради цельности смысла.
* Markdown Text Splitter. Для markdown-документов: режет по заголовкам и структуре, формируя логичные секции.
* Code Text Splitter. Для кода: учитывает структуру, функции и языковые конструкции, чтобы формировать осмысленные куски (например, для поиска по коду/документации).
* HTML-to-Markdown Text Splitter. Сначала конвертирует HTML в Markdown, затем применяет Markdown Splitter, что удобно для веб-страниц и HTML-документов.

Параметры настройки:

* Chunk Size — максимальный размер чанка (в символах или токенах).
* Chunk Overlap — перекрытие между соседними чанками (символы/токены) для сохранения контекста.


В этом гайде мы задали заметный Chunk Overlap, чтобы не терять данные на границах. Оптимальное значение зависит от сложности ваших данных; подбирайте под датасет и целевые сценарии извлечения.

<figure><img src="/assets/ds05.png" alt="" width="563"><figcaption></figcaption></figure>

## 4. Предпросмотр данных

Теперь можно посмотреть, как данные будут порезаны с текущей конфигурацией Text Splitter: `chunk_size=1500` и `chunk_overlap=750`.

<figure><img src="/assets/ds06.png" alt=""><figcaption></figcaption></figure>

Экспериментируйте с видами Splitter’ов, размером чанков и overlap, чтобы найти оптимальную конфигурацию. Предпросмотр помогает довести разбиение до нужного качества под вашу RAG-систему.

<figure><img src="/assets/ds07.png" alt=""><figcaption></figcaption></figure>

Обратите внимание: наш кастомный метаданный ключ `company: "liberty"` вставлен в каждый чанк. Он позволит легко фильтровать и извлекать данные именно этого датасета, даже если один и тот же индекс векторного хранилища используется для разных наборов данных.


### Понимание Chunk Overlap


В задачах векторного извлечения и запросов к БЯМ overlap важен для поддержания контекста и повышения точности ответов, особенно при ограниченной глубине извлечения (top K — максимум похожих чанков, возвращаемых из Vector Store на запрос).

При запросе БЯМ выполняет similarity-поиск по Vector Store и берёт самые релевантные чанки. Если top K невелик (дефолт: 4), модель изначально использует только эти 4 чанка для ответа.

Проблема: при отсутствии overlap и малом top K ответы могут быть неполными/неточными, если нужная информация растянута на несколько чанков.
Overlap решает это, «мостя» соседние чанки общим контекстом и повышая шанс, что весь релевантный фрагмент попадёт в выборку.
В итоге overlap помогает:
Сохранять контекстную непрерывность. Плавный переход между сегментами улучшает понимание текста.


Повышать точность извлечения. Растёт вероятность поймать всю нужную информацию в пределах выбранного top K.


Точность vs стоимость
Две основные ручки для баланса между точностью и стоимостью:
Увеличить/уменьшить Chunk Overlap. Больше overlap — лучше контекст, но дороже (больше чанков вовлечено). Меньше overlap — дешевле, но риск потери связующего контекста.


Увеличить/уменьшить Top K. Больше top K — выше точность (больше чанков учитывается), но дороже.


Совет: оптимум зависит от сложности документов, характеристик модели эмбеддингов и желаемого баланса точность/стоимость. Нужны эксперименты.

## 5. Обработайте данные

Когда качество разбиения устраивает, обработайте данные.

<figure><img src="/assets/ds08.png" alt=""><figcaption></figcaption></figure>


После обработки вы можете точечно редактировать отдельные чанки: удалять/добавлять содержимое.
Плюсы:
Более высокая точность. Исправляйте неточности исходника.


Лучшая релевантность. Подчёркивайте важное, убирайте шум.


Оптимизация под запросы. Адаптируйте формулировки чанков под ожидаемые вопросы пользователей.


## 6. Настройте процесс upsert


Когда данные загружены Document Loader’ом и корректно нарезаны, можно настраивать upsert.

<figure><img src="/assets/dastore002.png" alt=""><figcaption></figcaption></figure>

Процесс из трёх шагов:
Embedding. Выбор модели эмбеддингов для кодирования датасета в векторы.


Vector Store. Выбор векторного хранилища.


Record Manager (опционально). Компонент для управления записями в Vector Store (добавление/удаление без дублей).


<figure><img src="/assets/dastore003.png" alt=""><figcaption></figcaption></figure>

### Шаг 1: Выбор Embeddings


Нажмите «Выбрать эмбеддинги (Select Embeddings)» и укажите модель. В примере: провайдер OpenAI, модель text-embedding-ada-002 (1536 измерений).
Embedding — преобразование текста в числовой вектор (многомерный массив), отражающий смысл. Векторы позволяют БЯМ находить/сравнивать похожие тексты по расстоянию/схожести в многомерном пространстве.  

Размерность эмбеддингов и Vector Store 

Число измерений индекса Vector Store определяется моделью эмбеддингов (и наоборот). Больше измерений — больше нюансов смысла, но выше вычислительная стоимость.  


Например, Google `embedding-001` (768 измерений) теоретически дешевле, чем OpenAI `text-embedding-3-large` (3072 измерения). Но рост измерений даёт эффект до определённого предела (diminishing returns).
Важно: размерность эмбеддингов и индекса должна совпадать. Иначе upsert завершится ошибкой.

<figure><img src="/assets/dastore004.png" alt=""><figcaption></figcaption></figure>

### Шаг 2: Выбор Vector Store

Нажмите «Выбрать векторное хранилище (Select Vector Store)» и укажите хранилище. В примере для продакшена берём Upstash.
Vector Store — БД для хранения векторных эмбеддингов. Параметр top K задаёт максимум возвращаемых похожих чанков.
Малый top K даёт компактные, возможно более релевантные ответы; большой — шире охват (больше информации).

<figure><img src="/assets/dastore005.png" alt=""><figcaption></figcaption></figure>

### Шаг 3: Выбор Record Manager

Record Manager — опциональный, но полезный элемент флоу upsert. Он хранит учёт всех чанков, занесённых в Vector Store, и позволяет эффективно добавлять/удалять без дублей при следующих upsert’ах.
Подробная настройка описана в отдельном гайде.


<figure><img src="/assets/dastore006.png" alt=""><figcaption></figcaption></figure>

## 7. Выполните upsert в Vector Store

Чтобы начать upsert и записать данные в Vector Store, нажмите «Вставить/обновить (Upsert)».

<figure><img src="/assets/dastore013.png" alt=""><figcaption></figcaption></figure>

Как видно на иллюстрации, данные успешно занесены в векторную БД Upstash. Для оптимального хранения и извлечения данные разбиты на 85 чанков.

<figure><img src="/assets/dastore007.png" alt="" width="375"><figcaption></figcaption></figure>

## 8. Протестируйте датасет

Чтобы быстро проверить извлечение прямо из Document Store, используйте кнопку «Retrieval Query» — она выполнит тестовый запрос и покажет, как работает выдача

<figure><img src="/assets/dastore010.png" alt=""><figcaption></figcaption></figure>

В нашем примере по запросу о покрытии напольного покрытия кухни в полисе мы получаем 4 релевантных чанка из Upstash (наш Vector Store). Это ограничение задано параметром top K = 4, что помогает получить самое релевантное без избыточности.

<figure><img src="/assets/dastore009.png" alt=""><figcaption></figcaption></figure>

## 9. Протестируйте RAG


Наша RAG-система готова. БЯМ корректно интерпретирует запрос и использует релевантные чанки для развёрнутого ответа.
Agent-флоу
С Узлом Agent можно подключить Document Store:

<figure><img src="/assets/image (4) (1) (1) (1).png" alt="" width="200"><figcaption></figcaption></figure>  

<figure><img src="/assets/image (5) (1) (1).png" alt="" width="407"><figcaption></figcaption></figure>

(или подключаться напрямую к векторной БД и модели эмбеддингов)

<figure><img src="/assets/image (6) (1) (1).png" alt="" width="394"><figcaption></figcaption></figure>

#### Чат-флоу

Можно использовать заранее настроенное Vector Store:


<figure><img src="/assets/dastore011.png" alt=""><figcaption></figcaption></figure>

или Document Store (Vector):

<figure><img src="/assets/image (215).png" alt=""><figcaption></figcaption></figure>

## 10. API

Доступны API для создания, обновления и удаления Document Store. Ниже — два самых востребованных: Upsert и Refresh. Детали см. в Document Store API Reference.

### Upsert API

Есть несколько сценариев upsert — у каждого свой результат.


#### Сценарий 1

<figure><img src="/assets/Untitled-2025-02-02-1727.png" alt="" width="496"><figcaption></figcaption></figure>

В том же Document Store использовать существующую конфигурацию Document Loader, upsert как новый Document Loader.
`docId` — это ID существующего Document Loader. Обязателен в теле запроса


```python
import requests
import json

DOC_STORE_ID = "your_doc_store_id"
DOC_LOADER_ID = "your_doc_loader_id"
API_URL = f"http://localhost:3000/api/v1/document-store/upsert/{DOC_STORE_ID}"
API_KEY = "your_api_key_here"

form_data = {
    "files": ('my-another-file.pdf', open('my-another-file.pdf', 'rb'))
}

body_data = {
    "docId": DOC_LOADER_ID
}

headers = {
    "Authorization": f"Bearer {BEARER_TOKEN}"
}

def query(form_data):
    response = requests.post(API_URL, files=form_data, data=body_data, headers=headers)
    print(response)
    return response.json()

output = query(form_data)
print(output)

```

```js
const DOC_STORE_ID = "your_doc_store_id"
const DOC_LOADER_ID = "your_doc_loader_id"

let formData = new FormData();
formData.append("files", input.files[0]);
formData.append("docId", DOC_LOADER_ID)

async function query(formData) {
    const response = await fetch(
        `http://localhost:3000/api/v1/document-store/upsert/${DOC_STORE_ID}`,
        {
            method: "POST",
            headers: {
                "Authorization": "Bearer <your_api_key_here>"
            },
            body: formData
        }
    );
    const result = await response.json();
    return result;
}

query(formData).then((response) => {
    console.log(response);
});
```


#### Сценарий 2

<figure><img src="/assets/Untitled-2025-03-02-1727.png" alt="" width="563"><figcaption></figcaption></figure>

В том же Document Store заменить существующий Document Loader новыми файлами


```python
import requests
import json

DOC_STORE_ID = "your_doc_store_id"
DOC_LOADER_ID = "your_doc_loader_id"
API_URL = f"http://localhost:3000/api/v1/document-store/upsert/{DOC_STORE_ID}"
API_KEY = "your_api_key_here"

form_data = {
    "files": ('my-another-file.pdf', open('my-another-file.pdf', 'rb'))
}

body_data = {
    "docId": DOC_LOADER_ID,
    "replaceExisting": True
}

headers = {
    "Authorization": f"Bearer {BEARER_TOKEN}"
}

def query(form_data):
    response = requests.post(API_URL, files=form_data, data=body_data, headers=headers)
    print(response)
    return response.json()

output = query(form_data)
print(output)
```

```js
const DOC_STORE_ID = "your_doc_store_id";
const DOC_LOADER_ID = "your_doc_loader_id";

let formData = new FormData();
formData.append("files", input.files[0]);
formData.append("docId", DOC_LOADER_ID);
formData.append("replaceExisting", true);

async function query(formData) {
    const response = await fetch(
        `http://localhost:3000/api/v1/document-store/upsert/${DOC_STORE_ID}`,
        {
            method: "POST",
            headers: {
                "Authorization": "Bearer <your_api_key_here>"
            },
            body: formData
        }
    );
    const result = await response.json();
    return result;
}

query(formData).then((response) => {
    console.log(response);
});
```


#### Сценарий  3

<figure><img src="/assets/Untitled-2025-04-02-1727.png" alt="" width="439"><figcaption></figcaption></figure>

В том же Document Store выполнить upsert «с нуля» как новый Document Loader.
`loader`, `splitter`, `embedding`, `vectorStore` — обязательны в теле. recordManager — опционален.



```python
import requests
import json

DOC_STORE_ID = "your_doc_store_id"
API_URL = f"http://localhost:3000/api/v1/document-store/upsert/{DOC_STORE_ID}"
API_KEY = "your_api_key_here"

form_data = {
    "files": ('my-another-file.pdf', open('my-another-file.pdf', 'rb'))
}

loader = {
    "name": "pdfFile",
    "config": {} # you can leave empty to use default config
}

splitter = {
    "name": "recursiveCharacterTextSplitter",
    "config": {
        "chunkSize": 1400,
        "chunkOverlap": 100
    }
}

embedding = {
    "name": "openAIEmbeddings",
    "config": {
        "modelName": "text-embedding-ada-002",
        "credential": <your_credential_id>
    }
}

vectorStore = {
    "name": "pinecone",
    "config": {
        "pineconeIndex": "exampleindex",
        "pineconeNamespace": "examplenamespace",
        "credential":  <your_credential_i
    }
}

body_data = {
    "docId": DOC_LOADER_ID,
    "loader": json.dumps(loader),
    "splitter": json.dumps(splitter),
    "embedding": json.dumps(embedding),
    "vectorStore": json.dumps(vectorStore)
}

headers = {
    "Authorization": f"Bearer {BEARER_TOKEN}"
}

def query(form_data):
    response = requests.post(API_URL, files=form_data, data=body_data, headers=headers)
    print(response)
    return response.json()

output = query(form_data)
print(output)
```

```js
const DOC_STORE_ID = "your_doc_store_id";
const API_URL = `http://localhost:3000/api/v1/document-store/upsert/${DOC_STORE_ID}`;
const API_KEY = "your_api_key_here";

const formData = new FormData();
formData.append("files", new Blob([await (await fetch('my-another-file.pdf')).blob()]), "my-another-file.pdf");

const loader = {
    name: "pdfFile",
    config: {} // You can leave empty to use the default config
};

const splitter = {
    name: "recursiveCharacterTextSplitter",
    config: {
        chunkSize: 1400,
        chunkOverlap: 100
    }
};

const embedding = {
    name: "openAIEmbeddings",
    config: {
        modelName: "text-embedding-ada-002",
        credential: "your_credential_id"
    }
};

const vectorStore = {
    name: "pinecone",
    config: {
        pineconeIndex: "exampleindex",
        pineconeNamespace: "examplenamespace",
        credential: "your_credential_id"
    }
};

const bodyData = {
    docId: "DOC_LOADER_ID",
    loader: JSON.stringify(loader),
    splitter: JSON.stringify(splitter),
    embedding: JSON.stringify(embedding),
    vectorStore: JSON.stringify(vectorStore)
};

const headers = {
    "Authorization": `Bearer BEARER_TOKEN`
};

async function query() {
    try {
        const response = await fetch(API_URL, {
            method: "POST",
            headers: headers,
            body: formData
        });

        const result = await response.json();
        console.log(result);
        return result;
    } catch (error) {
        console.error("Error:", error);
    }
}

query();

```
Создание «с нуля» не рекомендуется, так как раскрывает credential ID. Рекомендация: создать «пустышку» Document Store и настроить параметры в UI, затем использовать её как базу для добавления нового Document Loader или создания нового Document Store.


#### Сценарий 4

<figure><img src="/assets/Untitled-2025-056-02-1727.png" alt="" width="533"><figcaption></figcaption></figure>

Создавать новый Document Store при каждом upsert.


```python
import requests
import json

DOC_STORE_ID = "your_doc_store_id"
DOC_LOADER_ID = "your_doc_loader_id"
API_URL = f"http://localhost:3000/api/v1/document-store/upsert/{DOC_STORE_ID}"
API_KEY = "your_api_key_here"

form_data = {
    "files": ('my-another-file.pdf', open('my-another-file.pdf', 'rb'))
}

body_data = {
    "docId": DOC_LOADER_ID,
    "createNewDocStore": True,
    "docStore": json.dumps({"name":"My NEW Doc Store"})
}

headers = {
    "Authorization": f"Bearer {BEARER_TOKEN}"
}

def query(form_data):
    response = requests.post(API_URL, files=form_data, data=body_data, headers=headers)
    print(response)
    return response.json()

output = query(form_data)
print(output)
```

```js
const DOC_STORE_ID = "your_doc_store_id";
const DOC_LOADER_ID = "your_doc_loader_id";

let formData = new FormData();
formData.append("files", input.files[0]);
formData.append("docId", DOC_LOADER_ID);
formData.append("createNewDocStore", true);
formData.append("docStore", JSON.stringify({ "name": "My NEW Doc Store" }));

async function query(formData) {
    const response = await fetch(
        `http://localhost:3000/api/v1/document-store/upsert/${DOC_STORE_ID}`,
        {
            method: "POST",
            headers: {
                "Authorization": "Bearer <your_api_key_here>"
            },
            body: formData
        }
    );
    const result = await response.json();
    return result;
}

query(formData).then((response) => {
    console.log(response);
});
```
`createNewDocStore` и `docStore` — обязательны в теле запроса.


#### Q: Где найти Document Store ID и Document Loader ID?


A: В URL соответствующих страниц.

<figure><img src="/assets/Picture1 (1).png" alt=""><figcaption></figcaption></figure>

#### Q:  Где посмотреть доступные конфиги для override?


A: Нажмите View API на нужном Document Loader.

<figure><img src="/assets/image (4) (3).png" alt=""><figcaption></figcaption></figure>

<figure><img src="/assets/image (2) (6).png" alt=""><figcaption></figcaption></figure>

При каждом upsert участвуют 5 элементов:

* **`loader`**
* **`splitter`**
* **`embedding`**
* **`vectorStore`**
* **`recordManager`**

Вы можете переопределять существующую конфигурацию через поле `config` нужного элемента. Например, согласно скриншоту, создать новый loader с другим `url`:


```python
import requests

API_URL = "http://localhost:3000/api/v1/document-store/upsert/<storeId>"

def query(payload):
    response = requests.post(API_URL, json=payload)
    return response.json()

output = query({
    "docId": <docLoaderId>,
    # override existing configuration
    "loader": {
        "config": {
            "url": "https://new-url.com"
        }
    }
})
print(output)
```

```js
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/document-store/upsert/<storeId>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        }
    );
    const result = await response.json();
    return result;
}

query({
    "docId": <docLoaderId>,
    "loader": {
        "config": {
            "url": "https://new-url.com"
        }
    }
}).then((response) => {
    console.log(response);
});
```


Что если loader загружает файлы? Тогда тело запроса — Form Data.

Например, чтобы переопределить параметр usage у PDF File Loader:

<figure><img src="/assets/image (4) (3) (1).png" alt=""><figcaption></figcaption></figure>

```python
import requests
import json

API_URL = "http://localhost:3000/api/v1/document-store/upsert/<storeId>"
API_KEY = "your_api_key_here"

form_data = {
    "files": ('my-another-file.pdf', open('my-another-file.pdf', 'rb'))
}

override_loader_config = {
    "config": {
        "usage": "perPage"
    }
}

body_data = {
    "docId": <docLoaderId>,
    "loader": json.dumps(override_loader_config) # Override existing configuration
}

headers = {
    "Authorization": f"Bearer {BEARER_TOKEN}"
}

def query(form_data):
    response = requests.post(API_URL, files=form_data, data=body_data, headers=headers)
    print(response)
    return response.json()

output = query(form_data)
print(output)
```

```js
const DOC_STORE_ID = "your_doc_store_id";
const DOC_LOADER_ID = "your_doc_loader_id";

const overrideLoaderConfig = {
    "config": {
        "usage": "perPage"
    }
}

let formData = new FormData();
formData.append("files", input.files[0]);
formData.append("docId", DOC_LOADER_ID);
formData.append("loader", JSON.stringify(overrideLoaderConfig));

async function query(formData) {
    const response = await fetch(
        `http://localhost:3000/api/v1/document-store/upsert/${DOC_STORE_ID}`,
        {
            method: "POST",
            headers: {
                "Authorization": "Bearer <your_api_key_here>"
            },
            body: formData
        }
    )
    const result = await response.json();
    return result;
}

query(formData).then((response) => {
    console.log(response);
});
```


#### Q: Когда использовать Form Data, а когда JSON в теле запроса?


A: Для Document Loaders с загрузкой файлов (PDF, DOCX, TXT и т. п.) используйте 

Form Data. Убедитесь, что тип файла совместим с ожидаемым. Например, PDF File Loader принимает только .pdf. Чтобы не плодить разные лоадеры под форматы, рекомендуется File Loader.


```python
import requests
import json

API_URL = "http://localhost:3000/api/v1/document-store/upsert/<storeId>"

# use form data to upload files
form_data = {
    "files": ('my-another-file.pdf', open('my-another-file.pdf', 'rb'))
}

body_data = {
    "docId": <docId>
}

def query(form_data):
    response = requests.post(API_URL, files=form_data, data=body_data)
    print(response)
    return response.json()

output = query(form_data)
print(output)
```

```
let formData = new FormData();
formData.append("files", input.files[0]);
formData.append("docId", <docId>);

async function query(formData) {
    const response = await fetch(
        "http://localhost:3000/api/v1/document-store/upsert/<storeId>",
        {
            method: "POST",
            body: formData
        }
    );
    const result = await response.json();
    return result;
}

query(formData).then((response) => {
    console.log(response);
});
```


Для Document Loaders без загрузки файла тело запроса — JSON:


```python
import requests

API_URL = "http://localhost:3000/api/v1/document-store/upsert/<storeId>"

def query(payload):
    response = requests.post(API_URL, json=payload)
    return response.json()

output = query({
    "docId": <docId>
})
print(output)
```

```
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/document-store/upsert/<storeId>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        }
    );
    const result = await response.json();
    return result;
}

query({
    "docId": <docId>
}).then((response) => {
    console.log(response);
});
```


#### Q: Можно ли добавить новые метаданные?


A: Да, передайте metadata в теле запроса:

```
{
    "docId": <doc-id>,
    "metadata": {
        "source: "abc"
    }
}
```

### Refresh API

Часто нужно переобработать все Document Loaders в Document Store, подтянуть свежие данные и выполнить upsert в Vector Store для синхронизации. Это делает 


```python
import requests

API_URL = "http://localhost:3000/api/v1/document-store/refresh/<storeId>"

def query():
    response = requests.post(API_URL)
    return response.json()

output = query()
print(output)
```

```javascript
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/document-store/refresh/<storeId>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            }
        }
    );
    const result = await response.json();
    return result;
}

query().then((response) => {
    console.log(response);
});
```


Можно переопределить конфигурации для конкретных Document Loader’ов:



```python
import requests

API_URL = "http://localhost:3000/api/v1/document-store/refresh/<storeId>"

def query(payload):
    response = requests.post(API_URL, json=payload)
    return response.json()

output = query(
{
    "items": [
        {
            "docId": <docId>,
            "splitter": {
                "name": "recursiveCharacterTextSplitter",
                "config": {
                    "chunkSize": 2000,
                    "chunkOverlap": 100
                }
            }
        }
    ]
}
)
print(output)
```

```
async function query(data) {
    const response = await fetch(
        "http://localhost:3000/api/v1/document-store/refresh/<storeId>",
        {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify(data)
        }
    );
    const result = await response.json();
    return result;
}

query({
    "items": [
        {
            "docId": <docId>,
            "splitter": {
                "name": "recursiveCharacterTextSplitter",
                "config": {
                    "chunkSize": 2000,
                    "chunkOverlap": 100
                }
            }
        }
    ]
}).then((response) => {
    console.log(response);
});
```


## 11. Summary

Мы создали Document Store для организации данных LibertyGuard Deluxe Homeowners Policy. Затем загрузили, нарезали на чанки, обработали и сделали upsert, подготовив данные для нашей RAG-системы.


Преимущества Document Store:
Организация и управление. Централизованное хранение, подготовка и администрирование данных.


Качество данных. Разбиение на чанки структурирует данные для точного извлечения и анализа.


Гибкость. Возможность корректировать и настраивать данные повышает точность и релевантность вашей RAG-системы.
