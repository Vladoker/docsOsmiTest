---
title: Document Store
description:
---


## Получить все хранилища документов

::field-group

    ::field{name="HTTP"}
    GET  `/document-store/store`  
    Возвращает список всех хранилищ документов
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

::

Коды ответов:  
* 200 — успешно (массив объектов)
* 500 — внутренняя ошибка



## Добавить или обновить документ в хранилище документов


::field-group
    ::field{name="HTTP"}
    POST `/document-store/upsert/{id}`  
    Добавить новый документ или обновить существующий в хранилище документов
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Параметры пути" type="string" required}
    `id` (string · uuid) — ID хранилища
    ::

    ::field{name="Тело (application/json):"}
    `docId` (string · uuid | nullable) — ID документа внутри хранилища (при передаче — переиспользуется конфигурация)  
    `metadata` (object | nullable) — метаданные (напр. `{"foo":"bar"}`)
    `replaceExisting` (boolean | nullable)  
    — заменить существующий загрузчик новыми чанками (не удаляет эмбеддинги из векторного хранилища)  
    `createNewDocStore` (boolean | nullable) — создать новое хранилище  
    `docStore` (object | nullable) — конфиг нового хранилища (если `createNewDocStore=true`)  
    `loader` (object | nullable) — конфиг загрузчика  
    `splitter` (object | nullable) — конфиг сплиттера  
    `embedding` (object | nullable) — конфиг эмбеддингов  
    `vectorStore` (object | nullable) — конфиг векторного хранилища  
    `recordManager` (object | nullable) — конфиг record manager  
    ::
::


Коды ответов:  

* 200 — операция выполнена
* 400 — некорректное тело запроса
* 500 — внутренняя ошибка

```json [Пример ответа]
{
  "numAdded": 1,
  "numDeleted": 1,
  "numUpdated": 1,
  "numSkipped": 1,
  "addedDocs": [
    {
      "pageContent": "This is the content of the page.",
      "metadata": { "author": "John Doe", "date": "2024-08-24" }
    }
  ]
}
```

## Повторно обработать и добавить или обновить все документы в хранилище документов  



::field-group
    ::field{name="HTTP"}
    POST `/document-store/refresh/{id}`  
    Повторно обработать и добавить или обновить все существующие документы в хранилище документов
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Параметры пути" type="string" required}
    `id` (string · uuid) — ID хранилища
    ::

    ::field{name="Тело (application/json):"}
    `items` (object[]) — массив конфигов для отдельных документов  
    (`docId`, `metadata`, `loader`, `splitter`, `embedding`, `vectorStore`, `recordManager`, и т.д.)
    ::
::


Коды ответов:  

* 200 — операция выполнена (массив результатов)
* 400 — некорректное тело запроса
* 500 — внутренняя ошибка

## Запрос на поиск в vector store  

::field-group
    ::field{name="HTTP"}
    POST `/document-store/vectorstore/query`  
    Запрос на поиск для вставленных (upserted) фрагментов
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Тело (application/json):"}
    `storeId` (string) — ID хранилища  
    `query` (string) — текст запроса
    ::
::

Коды ответов:  

* 200 — успешно (время выполнения и список найденных документов)
* 400 — некорректное тело запроса
* 500 — внутренняя ошибка

```json [Пример ответа]
{
  "timeTaken": 1,
  "docs": [
    {
      "pageContent": "This is the content of the page.",
      "metadata": { "author": "John Doe", "date": "2024-08-24" }
    }
  ]
}
```

## Создать новое хранилище документов

::field-group
    ::field{name="HTTP"}
    POST `/document-store/store`  
    Создаёт хранилище документов с переданными параметрами.
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Тело (application/json):"}
    `id` (string · uuid) — уникальный ID хранилища  
    `name` (string) — имя  
    `description` (string) — описание  
    `loaders` (string) — загрузчики (JSON-строка)  
    `whereUsed` (string) — места использования (JSON-строка)  
    `status` (string · enum) — статус: `EMPTY`|`SYNC`|`SYNCING`|`STALE`|`NEW`|`UPSERTING`|`UPSERTED`  
    `vectorStoreConfig` (string) — конфиг векторного хранилища (JSON-строка)  
    `embeddingConfig` (string) — конфиг эмбеддинга (JSON-строка)  
    `recordManagerConfig` (string) — конфиг record manager (JSON-строка)  
    `createdDate` (string · date-time) — дата создания  
    `updatedDate` (string · date-time) — дата обновления  
    ::
::

Коды ответов:  

* 200 — успешно создано
* 400 — некорректное тело запроса
* 500 — внутренняя ошибка

## Обновить конкретный чанк

::field-group
    ::field{name="HTTP"}
    PUT  `/document-store/chunks/{storeId}/{loaderId}/{chunkId}`  
    Обновляет выбранный чанк у загрузчика документов.
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Параметры пути"}
    `storeId` (string) — ID хранилища  
    `loaderId` (string) — ID загрузчика  
    `chunkId` (string) — ID чанка  
    ::

    ::field{name="Тело (application/json):"}
    `pageContent` (string) — содержимое
    `metadata` (object) — метаданные (напр. `{"author":"John Doe","date":"2024-08-24"}`)
    ::
::

Коды ответов:  

* 200 — успешно (возвращает обновлённый список чанков и метаданные файла)
* 404 — хранилище не найдено
* 500 — внутренняя ошибка

## Обновить хранилище документов по ID

::field-group
    ::field{name="HTTP"}
    PUT  `/document-store/store/{id}`  
    Обновляет сведения о хранилище по его ID.
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Параметры пути"}
    `id` (string · uuid) — ID хранилища
    ::

    ::field{name="Тело (application/json):"}
    (поля — как при создании)
    ::
::

Коды ответов:  

* 200 — успешно обновлено
* 404 — хранилище не найдено
* 500 — внутренняя ошибка

## Удалить хранилище документов по ID

::field-group
    ::field{name="HTTP"}
    DELETE  `/document-store/store/{id}`  
    Удаляет хранилище документов.
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Параметры пути" required}
    `id` (string · uuid) — ID хранилища
    ::
::

Коды ответов:  

* 200 — успешно удалено (без содержимого)
* 404 — хранилище не найдено
* 500 — внутренняя ошибка

## Удалить конкретный чанк

::field-group
    ::field{name="HTTP"}
    DELETE  `/document-store/chunks/{storeId}/{loaderId}/{chunkId}`  
    Удаляет указанный чанк из загрузчика документов.
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Параметры пути" required}
    `storeId` (string) — ID хранилища  
    `loaderId` (string) — ID загрузчика  
    `chunkId` (string) — ID чанка  
    ::
::

Коды ответов:  

* 200 — чанк удалён (без содержимого)
* 400 — некорректный ID
* 404 — хранилище не найдено
* 500 — внутренняя ошибка

## Удалить загрузчик и связанные чанки

::field-group
    ::field{name="HTTP"}
    DELETE  `/document-store/loader/{storeId}/{loaderId}`  
    Удаляет конкретный загрузчик и его чанки из хранилища. Данные из векторного хранилища не удаляются.
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::

    ::field{name="Параметры пути" required}
    `storeId` (string) — ID хранилища  
    `loaderId` (string) — ID загрузчика
    ::
::

Коды ответов:  

* 200 — загрузчик удалён (без содержимого)
* 400 — некорректный ID
* 404 — хранилище не найдено
* 500 — внутренняя ошибка

## Удалить данные из векторного хранилища

::field-group
    ::field{name="HTTP"}
    DELETE  `/document-store/vectorstore/{id}`  
    Удаляет из векторного хранилища только те данные, которые были upsert-нуты через **Record Manager**.
    ::

    ::field{name="Авторизация" type="string" required}
    bearerAuth `JWT-токен`
    ::
::

Коды ответов:  

* 200 — данные удалены (без содержимого)
* 400 — некорректный ID
* 404 — хранилище не найдено
* 500 — внутренняя ошибка